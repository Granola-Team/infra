* Terraform S3 Backend

** Introduction

This configuration creates an encrypted S3 bucket to store your
terraform state with versioning and a lifecycle rule to prevent
accidental deletions of the bucket.

** Export Instruction

You can export the source code from this literate program by running
the following command line program:

#+begin_src bash
  emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "README.org")'
#+end_src

You can tangle the README.org literate program  with following
shortcut =C-c C-v t= or =M-x org-babel-tangle-file= in emacs.

** Terraform versions

#+begin_src terraform :tangle versions.tf
  terraform {
    required_providers {
      aws = {
        source = "hashicorp/aws"
        version = "~> 4.0"
      }
    }
  }
#+end_src

** Terraform input variables

#+begin_src terraform :tangle variables.tf
  variable "region" {
    type        = string
    description = "AWS Region"
    default     = ["us-east-1"]
  }

  variable "environment" {
    type        = string
    description = "Type of environment"
  }
#+end_src

** Terraform output values

#+begin_src terraform :tangle outputs.tf
  // Output KMS private keys
#+end_src

** Terraform bootstrapping role

We will follow the principle of least privilege.

#+begin_src terraform :tangle policy.tf
  data "aws_iam_policy_document" "state" {
    statement {
      effect    = "Allow"
      actions   = [
        "s3:ListBucket",
        "s3:GetBucketVersioning",
      ]
      resources = [
        aws_s3_bucket.state.arn,
      ]
    }
    statement {
      effect    = "Allow"
      actions = [
        "s3:GetObject",
        "s3:PutObject",
      ]
      resources = [
        "${aws_s3_bucket.state.arn}/*"
      ]
    }
  }

  resource "aws_iam_role" "terraform_role" {
    name               = "terraform-role"
    assume_role_policy = data.aws_iam_policy_document.state.json
  }
#+end_src

** Provision KMS encryption key

It's our responsibility to secure our terraform state at rest. We will
provision a KMS key and convenience alias so that we may refer back to
it at a later time.

#+begin_src terraform :tangle kms.tf
  resource "aws_kms_key" "state_key" {
    description             = "This key is used to encrypt the terraform state bucket"
    deletion_window_in_days = 14
    enable_key_rotation     = true
  }

  resource "aws_kms_alias" "state_key_alias" {
    name          = "alias/state-${var.environment}-key"
    target_key_id = aws_kms_key.state_key.key_id
  }

#+end_src

** Provision S3 Bucket

Provision the s3 bucket and and associate IAM policies.

Requirements:
- Must be private and all public access blocked
- Must be versioned so we can fallback if something goes wrong
- Must prevent accidential deletion of s3 bucket
- Must enforce SSL to access contents of the bucket

*** TODO Create a S3 bucket for logging and Cloudtrail

#+begin_src terraform :tangle s3.tf
  resource "aws_s3_bucket" "state" {
    bucket = "granola-tfstate-${var.environment}"

    server_side_encryption_configuration {
      rule {
        apply_server_side_encryption_by_default {
          kms_master_key_id = aws_kms_key.state_key.arn
          sse_algorithm     = "aws:kms"
        }
      }
    }
  }

  resource "aws_s3_bucket_acl" "state" {
    bucket = aws_s3_bucket.state.id
    acl    = "private"
  }

  resource "aws_s3_bucket_versioning" "state" {
    bucket = aws_s3_bucket.state.id
    versioning_configuration {
      status = "Enabled"
    }
  }

  resource "aws_s3_bucket_policy" "state_force_ssl" {
    bucket = aws_s3_bucket.state.id
    policy = data.aws_iam_policy_document.state_force_ssl.json
    depends_on = [aws_s3_bucket_public_access_block.state]
  }

  data "aws_iam_policy_document" "state_force_ssl" {
    statement {
      sid       = "AllowSSLRequestsOnly"
      actions   = ["s3:*"]
      effect    = "Deny"
      resources = [
        aws_s3_bucket.state.arn,
        "${aws_s3_bucket.state.arn}/*"
      ]
      condition {
        test     = "Bool"
        variable = "aws:SecureTransport"
        values   = ["false"]
      }
      principals {
        type        = "*"
        identifiers = ["*"]
      }
    }
  }

  resource "aws_s3_bucket_public_access_block" "state" {
    bucket                  = aws_s3_bucket.state.id
    block_public_acls       = true
    block_public_policy     = true
    ignore_public_acls      = true
    restrict_public_buckets = true
  }
#+end_src

** Provision DynamoDB table

Create a DynamoDB table to enable concurrent edits and locking of the
state files.

#+begin_src terraform :tangle dynamodb.tf
  resource "aws_dynamodb_table" "state_lock" {
    name     = "granola-tfstate-lock-${var.environment}"
    hash_key = "LockID"

    attribute {
      name = "LockID"
      type = "S"
    }

    server_side_encryption {
      enabled     = var.dynamodb_enable_server_side_encryption
      kms_key_arn = aws_kms_key.state_key.arn
    }

    point_in_time_recovery {
      enabled = true
    }
  }
#+end_src

** Links & Stuff

[[https://developer.hashicorp.com/terraform/language/settings/backends/s3][S3 tfstate backend]]
