* Terraform Bootstrap

Before we can get started with our terraform IaC, we must first
bootstrap the s3 backend so that we have a central place to store our
terraform state.

** Terraform Bootstrapping Role

We will follow the principle of least privilege.

#+begin_src terraform
  resource "aws_iam_user" "terraform_user" {
    name = "Terraform User"
  }
#+end_src

** Provision KMS encryption key


[[https://docs.aws.amazon.com/kms/latest/developerguide/kms-alias.html][KMS alias documentation]]


#+begin_src terraform
  resource "aws_kms_key" "terraform_state_key" {
    description             = "This key is used to encrypt the terraform state bucket"
    deletion_window_in_days = 14
    enable_key_rotation     = true
  }

  resource "aws_kms_alias" "terraform_state_key_alias" {
    name          = "alias/terraform-state-${var.environment}-key"
    target_key_id = aws_kms_key.terraform_state_key.key_id
  }

#+end_src

** Provision S3 Bucket

Create Terraform IAM policy for fine grained access to manage the
Terraform state in S3 and DynamoDB.

*** Example S3 IAM Policy

#+begin_src javascript
  {
    "Version": "2012-10-17",
    "Statement": [
      {
        "Effect": "Allow",
        "Action": "s3:ListBucket",
        "Resource": "arn:aws:s3:::mybucket"
      },
      {
        "Effect": "Allow",
        "Action": ["s3:GetObject", "s3:PutObject", "s3:DeleteObject"],
        "Resource": "arn:aws:s3:::mybucket/path/to/my/key"
      }
    ]
  }

#+end_src

Provision the s3 bucket and iam policies

#+begin_src terraform
  resource "aws_s3_bucket" "state" {
    bucket = "granola-tfstate-${var.environment}"

    versioning {
      enabled = true
    }

    server_side_encryption_configuration {
      rule {
        apply_server_side_encryption_by_default {
          kms_master_key_id = aws_kms_key.state_key.arn
          sse_algorithm     = "aws:kms"
        }
      }
    }
  }

  resource "aws_s3_bucket_policy" "state_policy" {
    bucket = aws_s3_bucket.state.id
    policy = join("", data.aws_iam_policy_document.*.json)

  }
  // Force SSL
  data "aws_iam_policy_document" "state_force_ssl" {
    statement {
      sid       = "AllowSSLRequestsOnly"
      actions   = ["s3:*"]
      effect    = "Deny"
      resources = [
        aws_s3_bucket.state.arn,
        "${aws_s3_bucket.state.arn}/*"
      ]
      condition {
        test     = "Bool"
        variable = "aws:SecureTransport"
        values   = ["false"]
      }
      principals {
        type        = "*"
        identifiers = ["*"]
      }
    }
  }

  data "aws_iam_policy_document" "state" {
    statement {
      effect    = "Allow"
      actions   = [
        "s3:ListBucket",
      ]
      resources = [
        aws_s3_bucket.state.arn,
      ]
    }
    statement {
      effect    = "Allow"
      actions = [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject",
      ]
      resources = [
        "${aws_s3_bucket.state.arn}/${var.application}/terraform.tfstate",
      ]
    }
  }


#+end_src

*** Example DynamoDB IAM Policy

#+begin_src javascript
  {
    "Version": "2012-10-17",
    "Statement": [
        {
          "Effect" : "Allow",
          "Action" : [
            "dynamodb:DeleteItem",
            "dynamodb:GetItem",
            "dynamodb:PutItem",
            "dynamodb:Query",
            "dynamodb:UpdateItem"
          ],
          "Resource" : ["arn:aws:dynamodb:*:*:table/granola-state-lock-table"],
          "Condition" : {
            "ForAllValues:StringEquals" : {
              "dynamodb:LeadingKeys" : [
                "myorg-terraform-states/myapp/production/tfstate", // during a state lock the full state file is stored with this key
                "myorg-terraform-states/myapp/production/tfstate-md5" // after the lock is released a hash of the statefile's contents are stored with this key
              ]
            }
          }
        }
    ]
  }
#+end_src

** Provision DynamoDB table for TFState lock

#+begin_src terraform
  resource "aws_dynamodb_table" "terraform_state_lock" {
    name           = "granola-${var.environemnt}-state-lock"
    hash_key       = "LockID"

    attribute {
      name = "LockID"
      type = "S"
    }
  }
#+end_src

** KMS Key and Alias

It's our responsibility to secure our Terraform state at rest. We will
provision a KMS key and convenience alias so that we may refer back to
it at a later time.

#+begin_src terraform
  resource "aws_kms_key" "terraform_state_key" {
    description             = "This key is used to encrypt the terraform state bucket"
    deletion_window_in_days = 14
    enable_key_rotation     = true
  }

  resource "aws_kms_alias" "key-alias" {
    name          = "alias/terraform-bucket-key"
    target_key_id = aws_kms_key.terraform-bucket-key.key_id
  }
#+end_src

** Create encrypted S3 bucket

#+begin_src terraform
  resource "aws_s3_bucket" "terraform_state" {
    bucket = "mybucket"
    acl    = "private"
  
    versioning {
      enabled = true
    }
  
    server_side_encryption_configuration {
      rule {
        apply_server_side_encryption_by_default {
          kms_master_key_id = aws_kms_key.terraform_state_key.arn
          sse_algorithm     = "aws:kms"
        }
      }
    }
  }

  resource "aws_s3_bucket_public_access_block" "block" {
    bucket                  = aws_s3_bucket.terraform-state.id
    block_public_acls       = true
    block_public_policy     = true
    ignore_public_acls      = true
    restrict_public_buckets = true
  }
#+end_src

** Bucket format

#+begin_src bnf
  
#+end_src

** Terraform policy and Roles

Add the following IAM policies to the terraform user

- s3:ListBucket on arn:aws:s3:::mybucket
- s3:GetObject on arn:aws:s3:::mybucket/path/to/my/key
- s3:PutObject on arn:aws:s3:::mybucket/path/to/my/key
- s3:DeleteObject on arn:aws:s3:::mybucket/path/to/my/key

#+begin_src terraform
  resource "aws_iam_role" "s3_access_role" {
    name               = "s3-terraform-role"
    assume_role_policy = <<-EOT
    {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": "s3:ListBucket",
          "Resource": "arn:aws:s3:::mybucket"
        },
        {
          "Effect": "Allow",
          "Action": ["s3:GetObject", "s3:PutObject", "s3:DeleteObject"],
          "Resource": "arn:aws:s3:::mybucket/path/to/my/key"
        }
      ]
    }
    EOT
  }
#+end_src

** Links & Stuff

[[https://developer.hashicorp.com/terraform/language/settings/backends/s3][S3 tfstate backend]]

* Datasource configuration

We must provision the s3 bucket and all it's prerequisite prior to
using the s3 bucket.

#+begin_src terraform
  terraform {
    backend "s3" {
      encrypt        = true
      bucket         = "mina-production"
      key            = "path/to/my/key"
      region         = "ca-central-1"
      dynamodb_table = "terraform-tfstate"      
    }
  }
#+end_src
